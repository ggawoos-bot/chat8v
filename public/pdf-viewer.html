<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>PDF ë·°ì–´</title>
  <!-- PDF ê²€ìƒ‰ ë©”ì‹œì§€ í•¸ë“¤ëŸ¬ -->
  <script src="../utils/pdfSearchMessageHandler.js" defer></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
        'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
        sans-serif;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      background: #f5f5f5;
    }
    
    #pdf-viewer-container {
      width: 100%;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }
    
    .header {
      background: white;
      border-bottom: 1px solid #e0e0e0;
      padding: 12px 16px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      flex-shrink: 0;
    }
    
    .header-top {
      display: flex;
      align-items: center;
      justify-content: space-between;
      width: 100%;
    }
    
    .title {
      font-size: 16px;
      font-weight: 600;
      color: #333;
      flex: 1;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    
    .controls {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .search-container {
      display: flex;
      align-items: center;
      gap: 8px;
      width: 100%;
      max-width: 400px;
    }
    
    .search-input {
      flex: 1;
      padding: 6px 12px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 14px;
      min-width: 0;
    }
    
    .search-input:focus {
      outline: none;
      border-color: #4285f4;
    }
    
    .search-button {
      padding: 6px 12px;
      border: 1px solid #ddd;
      background: #4285f4;
      color: white;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      white-space: nowrap;
      transition: all 0.2s;
    }
    
    .search-button:hover:not(:disabled) {
      background: #357ae8;
    }
    
    .search-button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .search-nav {
      display: flex;
      align-items: center;
      gap: 4px;
    }
    
    .search-nav button {
      padding: 4px 8px;
      border: 1px solid #ddd;
      background: white;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      min-width: 32px;
    }
    
    .search-nav button:hover:not(:disabled) {
      background: #f0f0f0;
    }
    
    .search-nav button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .controls button {
      padding: 6px 12px;
      border: 1px solid #ddd;
      background: white;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.2s;
    }
    
    .controls button:hover:not(:disabled) {
      background: #f0f0f0;
    }
    
    .controls button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .page-info {
      display: flex;
      align-items: center;
      gap: 8px;
      margin: 0 8px;
    }
    
    .page-input {
      width: 60px;
      padding: 4px 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
      text-align: center;
      font-size: 14px;
    }
    
    .viewer-wrapper {
      flex: 1;
      overflow: auto;
      background: #525252;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }
    
    .loading {
      color: white;
      font-size: 16px;
    }
    
    .error {
      color: #ff4444;
      text-align: center;
      padding: 20px;
    }
    
    .error-message {
      margin-top: 12px;
      font-size: 14px;
    }
    
    canvas {
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
      max-width: 100%;
      height: auto;
    }
    
    /* í…ìŠ¤íŠ¸ ë ˆì´ì–´ ìŠ¤íƒ€ì¼ */
    .textLayer {
      position: absolute;
      left: 0;
      top: 0;
      right: 0;
      bottom: 0;
      overflow: hidden;
      opacity: 1;
      line-height: 1.0;
    }
    
    .textLayer span {
      color: transparent;
      position: absolute;
      white-space: pre;
      cursor: text;
      transform-origin: 0% 0%;
    }
    
    .textLayer .highlight {
      background-color: rgba(255, 255, 0, 0.4); /* âœ… ë” ì§„í•˜ê²Œ (0.15 â†’ 0.4) */
      border: 1px solid rgba(255, 200, 0, 0.6); /* âœ… ë” ì§„í•˜ê²Œ (0.3 â†’ 0.6) */
      border-radius: 2px;
      padding: 1px 2px;
      color: #000 !important; /* âœ… ì–´ë‘ìš´ í…ìŠ¤íŠ¸ ìƒ‰ìƒìœ¼ë¡œ ëŒ€ë¹„ ê°œì„  */
    }
    
    .textLayer .highlight-strong {
      background-color: rgba(255, 200, 0, 0.5); /* âœ… ë” ì§„í•˜ê²Œ (0.25 â†’ 0.5) */
      border: 2px solid rgba(255, 150, 0, 0.8); /* âœ… ë” ì§„í•˜ê²Œ (0.4 â†’ 0.8, 1px â†’ 2px) */
      border-radius: 3px;
      padding: 2px 3px;
      font-weight: normal; /* âœ… bold ì œê±°í•˜ì—¬ ê¸€ì”¨ ê°€ë…ì„± í–¥ìƒ */
      color: #000 !important; /* âœ… ì–´ë‘ìš´ í…ìŠ¤íŠ¸ ìƒ‰ìƒìœ¼ë¡œ ëŒ€ë¹„ ê°œì„  */
    }
    
    .textLayer .highlight-current {
      background-color: rgba(255, 255, 255, 0.95) !important; /* âœ… ë°ì€ í°ìƒ‰ ë°°ê²½ìœ¼ë¡œ ëŒ€ë¹„ í–¥ìƒ */
      color: #1a73e8 !important; /* âœ… íŒŒë€ìƒ‰ í…ìŠ¤íŠ¸ */
      border: 2px solid #1a73e8 !important; /* âœ… íŒŒë€ìƒ‰ í…Œë‘ë¦¬ */
      border-radius: 3px;
      padding: 2px 3px;
      font-weight: 700 !important; /* âœ… êµµê²Œ */
      box-shadow: 0 0 6px rgba(26, 115, 232, 0.5);
    }
  </style>
</head>
<body>
  <div id="pdf-viewer-container">
    <div class="header">
      <div class="header-top">
        <div class="title" id="pdf-title">PDF ë¡œë”© ì¤‘...</div>
        <div class="controls">
          <button id="prev-btn" disabled>â† ì´ì „</button>
          <div class="page-info">
            <span>í˜ì´ì§€</span>
            <input type="number" id="page-input" min="1" value="1" disabled>
            <span id="total-pages">/ ?</span>
          </div>
          <button id="next-btn" disabled>ë‹¤ìŒ â†’</button>
          <button id="close-btn">ë‹«ê¸°</button>
        </div>
      </div>
      <div class="search-container">
        <input 
          type="text" 
          id="search-input" 
          class="search-input" 
          placeholder="í˜„ì¬ ë¬¸ì„œì—ì„œ ê²€ìƒ‰..."
          autocomplete="off"
        />
        <button id="search-button" class="search-button" disabled>ê²€ìƒ‰</button>
        <div class="search-nav" id="search-nav" style="display: none;">
          <button id="search-prev-btn" disabled>â€¹</button>
          <span id="search-counter" style="font-size: 12px; color: #666; padding: 0 8px;">0/0</span>
          <button id="search-next-btn" disabled>â€º</button>
        </div>
      </div>
    </div>
    <div class="viewer-wrapper" id="viewer-wrapper">
      <div class="loading">PDF ë¡œë”© ì¤‘...</div>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script>
    // PDF.js Worker ì„¤ì •
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    
    // URL íŒŒë¼ë¯¸í„°ì—ì„œ ì •ë³´ ê°€ì ¸ì˜¤ê¸°
    const urlParams = new URLSearchParams(window.location.search);
    const pdfUrlParam = urlParams.get('url') || '';
    const pdfUrl = pdfUrlParam ? decodeURIComponent(pdfUrlParam) : '';
    const initialPage = parseInt(urlParams.get('page') || '1', 10);
    const titleParam = urlParams.get('title') || '';
    const title = titleParam ? decodeURIComponent(titleParam) : 'PDF ë¬¸ì„œ';
    
    // í•˜ì´ë¼ì´íŠ¸ í‚¤ì›Œë“œ ê°€ì ¸ì˜¤ê¸° (ë³€ìˆ˜ë¡œ ì„ ì–¸í•˜ì—¬ ë‚˜ì¤‘ì— ì—…ë°ì´íŠ¸ ê°€ëŠ¥í•˜ê²Œ)
    const highlightParam = urlParams.get('highlight') || '';
    let searchTextParam = urlParams.get('searchText') || '';
    let highlightKeywords = highlightParam 
      ? highlightParam.split(',').filter(k => k.trim().length > 0).map(k => decodeURIComponent(k.trim()))
      : [];
    
    console.log('ğŸ“„ PDF ë·°ì–´ ì´ˆê¸°í™”:', {
      pdfUrl: pdfUrl,
      initialPage: initialPage,
      title: title,
      highlightKeywords: highlightKeywords,
      searchText: searchTextParam.substring(0, 50),
      fullUrl: window.location.href
    });
    
    if (!pdfUrl) {
      const errorHtml = '<div class="error"><div>âŒ PDF URLì´ ì œê³µë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.</div><div class="error-message">URL íŒŒë¼ë¯¸í„°ë¥¼ í™•ì¸í•˜ì„¸ìš”.</div></div>';
      document.getElementById('viewer-wrapper').innerHTML = errorHtml;
      console.error('âŒ PDF URLì´ ì—†ìŠµë‹ˆë‹¤. URL íŒŒë¼ë¯¸í„°:', window.location.search);
      throw new Error('PDF URLì´ ì—†ìŠµë‹ˆë‹¤.');
    }
    
    // ì œëª© ì„¤ì •
    document.getElementById('pdf-title').textContent = title;
    
    // âœ… ê²€ìƒ‰ ì…ë ¥ í•„ë“œ í¬ì»¤ìŠ¤ í•¨ìˆ˜ (ì—¬ëŸ¬ ì‹œì ì—ì„œ í˜¸ì¶œ)
    function focusSearchInput() {
      const searchInput = document.getElementById('search-input');
      if (searchInput && document.activeElement !== searchInput) {
        try {
          searchInput.focus();
          console.log('âœ… ê²€ìƒ‰ ì…ë ¥ í•„ë“œì— í¬ì»¤ìŠ¤ ì„¤ì •');
        } catch (e) {
          console.warn('âš ï¸ í¬ì»¤ìŠ¤ ì„¤ì • ì‹¤íŒ¨:', e);
        }
      }
    }
    
    // âœ… DOM ë¡œë“œ ì™„ë£Œ ì‹œ í¬ì»¤ìŠ¤ ì‹œë„
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => {
        setTimeout(focusSearchInput, 100);
      });
    } else {
      setTimeout(focusSearchInput, 100);
    }
    
    let pdfDoc = null;
    let currentPage = initialPage;
    let numPages = 0;
    let pageRendering = false;
    let pageNumPending = null;
    // âœ… PDF.js ì¢Œí‘œ ê¸°ë°˜ ë§¤ì¹­ì„ ìœ„í•œ ì „ì—­ ë³€ìˆ˜
    let currentPageTextContent = null; // í˜„ì¬ í˜ì´ì§€ì˜ textContent ì €ì¥
    // âœ… PDF ë¡œë“œ ì „ ìˆ˜ì‹ ëœ ë©”ì‹œì§€ë¥¼ ì €ì¥í•˜ëŠ” í
    const queuedMessages = [];
    
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const viewerWrapper = document.getElementById('viewer-wrapper');
    viewerWrapper.innerHTML = '';
    
    // ìº”ë²„ìŠ¤ì™€ í…ìŠ¤íŠ¸ ë ˆì´ì–´ë¥¼ ë‹´ì„ ì»¨í…Œì´ë„ˆ ìƒì„±
    const pageContainer = document.createElement('div');
    pageContainer.style.position = 'relative';
    pageContainer.style.display = 'inline-block';
    viewerWrapper.appendChild(pageContainer);
    pageContainer.appendChild(canvas);
    
    // í…ìŠ¤íŠ¸ ë ˆì´ì–´ ì»¨í…Œì´ë„ˆ ìƒì„±
    const textLayerDiv = document.createElement('div');
    textLayerDiv.className = 'textLayer';
    pageContainer.appendChild(textLayerDiv);
    
    // ìš”ì†Œ ì°¸ì¡°
    const prevBtn = document.getElementById('prev-btn');
    const nextBtn = document.getElementById('next-btn');
    const pageInput = document.getElementById('page-input');
    const totalPagesSpan = document.getElementById('total-pages');
    const closeBtn = document.getElementById('close-btn');
    const searchInput = document.getElementById('search-input');
    const searchButton = document.getElementById('search-button');
    const searchNav = document.getElementById('search-nav');
    const searchPrevBtn = document.getElementById('search-prev-btn');
    const searchNextBtn = document.getElementById('search-next-btn');
    const searchCounter = document.getElementById('search-counter');
    
    // ê²€ìƒ‰ ê´€ë ¨ ë³€ìˆ˜
    let searchResults = []; // { page: number, index: number } í˜•íƒœì˜ ê²€ìƒ‰ ê²°ê³¼ ë°°ì—´
    let currentSearchIndex = -1;
    let currentSearchText = '';
    
    // PDF ë¡œë“œ
    console.log('ğŸ“¥ PDF ë¡œë”© ì‹œì‘:', pdfUrl);
    pdfjsLib.getDocument({
      url: pdfUrl,
      httpHeaders: {},
      withCredentials: false
    }).promise.then((pdf) => {
      pdfDoc = pdf;
      numPages = pdf.numPages;
      
      totalPagesSpan.textContent = `/ ${numPages}`;
      pageInput.max = numPages;
      pageInput.disabled = false;
      prevBtn.disabled = false;
      nextBtn.disabled = false;
      searchButton.disabled = false;
      
      // âœ… URLì—ì„œ ê²€ìƒ‰ í…ìŠ¤íŠ¸ê°€ ìˆì–´ë„ ê²€ìƒ‰ì°½ì— ìë™ ì…ë ¥í•˜ì§€ ì•ŠìŒ
      // (í•˜ì´ë¼ì´íŠ¸ëŠ” searchTextParamì„ ì‚¬ìš©í•˜ë¯€ë¡œ ìœ ì§€)
      // if (searchTextParam) {
      //   searchInput.value = searchTextParam;
      //   performSearch(searchTextParam);
      // }
      
      // âœ… íì— ìŒ“ì¸ ë©”ì‹œì§€ ì²˜ë¦¬ (PDF ë¡œë“œ ì „ì— ë°›ì€ ë©”ì‹œì§€ë“¤)
      if (queuedMessages.length > 0) {
        console.log(`ğŸ“¥ íì— ìŒ“ì¸ ${queuedMessages.length}ê°œ ë©”ì‹œì§€ ì²˜ë¦¬ ì‹œì‘`);
        queuedMessages.forEach((msg) => {
          processChangePageMessage(msg);
        });
        queuedMessages.length = 0; // í ë¹„ìš°ê¸°
      }
      
      // ì´ˆê¸° í˜ì´ì§€ ë Œë”ë§ (í ì²˜ë¦¬ í›„, ë§ˆì§€ë§‰ ë©”ì‹œì§€ì˜ í˜ì´ì§€ê°€ ìˆìœ¼ë©´ ê·¸ê²ƒìœ¼ë¡œ, ì—†ìœ¼ë©´ initialPageë¡œ)
      renderPage(currentPage);
      
      console.log('âœ… PDF ë¡œë“œ ì™„ë£Œ:', numPages, 'í˜ì´ì§€');
      
      // âœ… ê²€ìƒ‰ ì…ë ¥ í•„ë“œì— ìë™ í¬ì»¤ìŠ¤ (PDF ë¡œë“œ ì™„ë£Œ í›„)
      setTimeout(focusSearchInput, 300);
    }).catch((error) => {
      console.error('âŒ PDF ë¡œë“œ ì˜¤ë¥˜:', error);
      console.error('âŒ PDF URL:', pdfUrl);
      console.error('âŒ ì „ì²´ ì—ëŸ¬ ê°ì²´:', error);
      
      let errorMessage = error.message || 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜';
      if (error.name === 'MissingPDFException') {
        errorMessage = 'PDF íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. íŒŒì¼ ê²½ë¡œë¥¼ í™•ì¸í•˜ì„¸ìš”.';
      } else if (error.name === 'InvalidPDFException') {
        errorMessage = 'ìœ íš¨í•˜ì§€ ì•Šì€ PDF íŒŒì¼ì…ë‹ˆë‹¤.';
      } else if (error.message && error.message.includes('Network')) {
        errorMessage = 'ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ì—°ê²°ì„ í™•ì¸í•˜ì„¸ìš”.';
      } else if (error.message && error.message.includes('CORS')) {
        errorMessage = 'CORS ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ì„œë²„ ì„¤ì •ì„ í™•ì¸í•˜ì„¸ìš”.';
      }
      
      viewerWrapper.innerHTML = `
        <div class="error">
          <div>âŒ PDF ë¡œë“œ ì‹¤íŒ¨</div>
          <div class="error-message">${errorMessage}</div>
          <div class="error-message" style="margin-top: 8px; font-size: 12px; color: #999;">URL: ${pdfUrl}</div>
          <div class="error-message" style="margin-top: 4px; font-size: 11px; color: #aaa;">ì—ëŸ¬ íƒ€ì…: ${error.name || 'Unknown'}</div>
        </div>
      `;
    });
    
    // í˜ì´ì§€ ë Œë”ë§ (í…ìŠ¤íŠ¸ ë ˆì´ì–´ ë° í•˜ì´ë¼ì´íŠ¸ í¬í•¨)
    function renderPage(num) {
      console.log(`ğŸ”„ renderPage í˜¸ì¶œ: ${num} (í˜„ì¬: ${currentPage}, ë Œë”ë§ ì¤‘: ${pageRendering})`);
      pageRendering = true;
      
      // âœ… í˜ì´ì§€ ì…ë ¥ í•„ë“œ ì¦‰ì‹œ ì—…ë°ì´íŠ¸
      pageInput.value = num;
      updateButtons();
      
      pdfDoc.getPage(num).then((page) => {
        console.log(`ğŸ“„ PDF í˜ì´ì§€ ${num} ë¡œë“œ ì™„ë£Œ, ë Œë”ë§ ì‹œì‘`);
        const viewport = page.getViewport({ scale: 1.5 });
        canvas.height = viewport.height;
        canvas.width = viewport.width;
        
        const renderContext = {
          canvasContext: ctx,
          viewport: viewport
        };
        
        const renderTask = page.render(renderContext);
        
        renderTask.promise.then(() => {
          console.log(`âœ… PDF í˜ì´ì§€ ${num} ìº”ë²„ìŠ¤ ë Œë”ë§ ì™„ë£Œ`);
          
          // âœ… ì´ˆê¸° í˜ì´ì§€ ë Œë”ë§ ì™„ë£Œ ì‹œ ê²€ìƒ‰ ì…ë ¥ í•„ë“œì— í¬ì»¤ìŠ¤
          if (num === currentPage && !pageRendering) {
            setTimeout(focusSearchInput, 100);
          }
          
          // í…ìŠ¤íŠ¸ ë ˆì´ì–´ ë Œë”ë§ ë° í•˜ì´ë¼ì´íŠ¸
          return page.getTextContent();
        }).then((textContent) => {
          // âœ… PDF.js ì¢Œí‘œ ê¸°ë°˜ ë§¤ì¹­ì„ ìœ„í•´ textContent ì €ì¥
          currentPageTextContent = textContent;
          
          // í…ìŠ¤íŠ¸ ë ˆì´ì–´ ì´ˆê¸°í™”
          textLayerDiv.innerHTML = '';
          textLayerDiv.style.width = viewport.width + 'px';
          textLayerDiv.style.height = viewport.height + 'px';
          
          // PDF.jsì˜ í…ìŠ¤íŠ¸ ë ˆì´ì–´ ë Œë”ë§
          // PDF.js 3.x ë²„ì „ì—ì„œëŠ” renderTextLayer ì‚¬ìš©
          try {
            pdfjsLib.renderTextLayer({
              textContentSource: textContent,
              container: textLayerDiv,
              viewport: viewport,
              textDivs: []
            });
          } catch (error) {
            console.warn('í…ìŠ¤íŠ¸ ë ˆì´ì–´ ë Œë”ë§ ì‹¤íŒ¨ (ê³„ì† ì§„í–‰):', error);
            // í…ìŠ¤íŠ¸ ë ˆì´ì–´ ì‹¤íŒ¨í•´ë„ PDFëŠ” ê³„ì† í‘œì‹œ
          }
          
          // í•˜ì´ë¼ì´íŠ¸ ì ìš© ë° ìŠ¤í¬ë¡¤ (í…ìŠ¤íŠ¸ ë ˆì´ì–´ê°€ ë Œë”ë§ëœ í›„)
          setTimeout(() => {
            // âœ… ê²€ìƒ‰ì–´ê°€ ìˆìœ¼ë©´ ê²€ìƒ‰ì–´ë¥¼ ìš°ì„  ì‚¬ìš©, ì—†ìœ¼ë©´ URL íŒŒë¼ë¯¸í„° ì‚¬ìš©
            const highlightText = currentSearchText || searchTextParam;
            
            // ê²€ìƒ‰ì–´ê°€ ìˆìœ¼ë©´ ê²€ìƒ‰ì–´ë¡œ í•˜ì´ë¼ì´íŠ¸ (í‚¤ì›Œë“œ ë¬´ì‹œ)
            if (currentSearchText) {
              applyHighlight(textLayerDiv, [], currentSearchText, currentSearchIndex);
            } else {
              applyHighlight(textLayerDiv, highlightKeywords, highlightText, -1);
            }
            
            // âœ… í•˜ì´ë¼ì´íŠ¸ ìœ„ì¹˜ë¡œ ìŠ¤í¬ë¡¤ (ì—¬ëŸ¬ ë²ˆ ì‹œë„í•˜ì—¬ í™•ì‹¤íˆ ë³´ì´ë„ë¡)
            scrollToHighlight(textLayerDiv, 0);
            
            // âœ… ì¶”ê°€ ì‹œë„: DOM ì—…ë°ì´íŠ¸ê°€ ëŠ¦ì„ ìˆ˜ ìˆìœ¼ë¯€ë¡œ
            setTimeout(() => {
              scrollToHighlight(textLayerDiv, 1);
            }, 500);
            
            // âœ… ìµœì¢… ì‹œë„: í™•ì‹¤íˆ ë³´ì´ë„ë¡
            setTimeout(() => {
              scrollToHighlight(textLayerDiv, 2);
            }, 1000);
            
            console.log(`âœ… í˜ì´ì§€ ${num} ë Œë”ë§ ë° í•˜ì´ë¼ì´íŠ¸ ì™„ë£Œ`);
          }, 300); // 500msì—ì„œ 300msë¡œ ë‹¨ì¶•í•˜ì—¬ ë” ë¹ ë¥¸ ë°˜ì‘
          
          // í˜ì´ì§€ ì „í™˜ í›„ ìŠ¤í¬ë¡¤ ìœ„ì¹˜ ì´ˆê¸°í™” (í•˜ì´ë¼ì´íŠ¸ ìŠ¤í¬ë¡¤ ì „ì— ìƒë‹¨ìœ¼ë¡œ)
          // ì£¼ì˜: scrollToHighlightì—ì„œ ë‹¤ì‹œ ìŠ¤í¬ë¡¤í•˜ë¯€ë¡œ ì´ ë¶€ë¶„ì€ ì œê±°í•˜ê±°ë‚˜ ìˆœì„œ ì¡°ì • í•„ìš”
          // scrollToHighlightê°€ í•˜ì´ë¼ì´íŠ¸ë¥¼ ì°¾ì§€ ëª»í•œ ê²½ìš°ì—ë§Œ ìƒë‹¨ìœ¼ë¡œ ìŠ¤í¬ë¡¤
          
          pageRendering = false;
          console.log(`âœ… í˜ì´ì§€ ${num} ë Œë”ë§ ì™„ì „íˆ ì™„ë£Œ`);
          
          // âœ… ì´ˆê¸° í˜ì´ì§€ ë Œë”ë§ ì™„ë£Œ ì‹œ ê²€ìƒ‰ ì…ë ¥ í•„ë“œì— í¬ì»¤ìŠ¤
          if (num === currentPage && num === initialPage) {
            setTimeout(focusSearchInput, 100);
          }
          
          if (pageNumPending !== null) {
            const pending = pageNumPending;
            pageNumPending = null;
            console.log(`ğŸ“„ ëŒ€ê¸° ì¤‘ì¸ í˜ì´ì§€ ${pending} ë Œë”ë§ ì‹œì‘`);
            renderPage(pending);
          }
        }).catch((error) => {
          console.error('í…ìŠ¤íŠ¸ ë ˆì´ì–´ ë Œë”ë§ ì˜¤ë¥˜:', error);
          pageRendering = false;
          if (pageNumPending !== null) {
            const pending = pageNumPending;
            pageNumPending = null;
            console.log(`ğŸ“„ ì˜¤ë¥˜ í›„ ëŒ€ê¸° ì¤‘ì¸ í˜ì´ì§€ ${pending} ë Œë”ë§ ì‹œì‘`);
            renderPage(pending);
          }
        });
      }).catch((error) => {
        console.error(`âŒ PDF í˜ì´ì§€ ${num} ë¡œë“œ ì‹¤íŒ¨:`, error);
        pageRendering = false;
        if (pageNumPending !== null) {
          const pending = pageNumPending;
          pageNumPending = null;
          renderPage(pending);
        }
      });
    }
    
    // âœ… í…ìŠ¤íŠ¸ ì •ê·œí™” í•¨ìˆ˜ (ë§¤ì¹­ìš©) - ê³µë°±, íŠ¹ìˆ˜ë¬¸ì ì •ê·œí™”ë¡œ ë§¤ì¹­ ì •í™•ë„ í–¥ìƒ
    function normalizeTextForMatching(text) {
      if (!text) return '';
      return text
        .replace(/\s+/g, ' ')           // ì—°ì† ê³µë°±ì„ í•˜ë‚˜ë¡œ
        .replace(/[\n\r\t]/g, ' ')      // ì¤„ë°”ê¿ˆ/íƒ­ì„ ê³µë°±ìœ¼ë¡œ
        .replace(/[^\wê°€-í£\s:;]/g, '') // íŠ¹ìˆ˜ë¬¸ì ì œê±° (í•œê¸€, ì˜ë¬¸, ìˆ«ì, ì½œë¡ , ì„¸ë¯¸ì½œë¡ ë§Œ ìœ ì§€)
        .toLowerCase()
        .trim();
    }
    
    // âœ… ë‹¨ì–´ ìœ ì‚¬ë„ ë§¤ì¹­ í•¨ìˆ˜ (ì¶”ê°€ ê°œì„  ì‚¬í•­)
    function isWordSimilar(word1, word2, threshold = 0.8) {
      if (!word1 || !word2) return false;
      
      const longer = word1.length > word2.length ? word1 : word2;
      const shorter = word1.length > word2.length ? word2 : word1;
      
      // ì™„ì „ ì¼ì¹˜
      if (longer === shorter) return true;
      
      // í¬í•¨ ê´€ê³„ í™•ì¸
      if (longer.includes(shorter)) return true;
      
      // ì§§ì€ ë‹¨ì–´ê°€ 3ì ì´ìƒì´ê³ , ê¸´ ë‹¨ì–´ê°€ ì§§ì€ ë‹¨ì–´ì˜ ì•ë¶€ë¶„ì„ í¬í•¨í•˜ëŠ” ê²½ìš°
      if (shorter.length >= 3 && longer.includes(shorter.substring(0, shorter.length - 1))) {
        return true;
      }
      
      // í•œê¸€ì˜ ê²½ìš° ìëª¨ ë‹¨ìœ„ ìœ ì‚¬ë„ (ê°„ë‹¨í•œ ë²„ì „)
      if (longer.length >= 3 && shorter.length >= 3) {
        // ì²« ê¸€ìì™€ ë§ˆì§€ë§‰ ê¸€ìê°€ ê°™ìœ¼ë©´ ìœ ì‚¬í•˜ë‹¤ê³  íŒë‹¨
        if (longer[0] === shorter[0] && longer[longer.length - 1] === shorter[shorter.length - 1]) {
          return true;
        }
      }
      
      return false;
    }
    
    // âœ… í•´ì‹œ ìƒì„± í•¨ìˆ˜ (ì •ê·œí™”ëœ í…ìŠ¤íŠ¸ì˜ í•´ì‹œê°’ ìƒì„±)
    function createTextHash(text) {
      const normalized = normalizeTextForMatching(text);
      let hash = 0;
      for (let i = 0; i < normalized.length; i++) {
        const char = normalized.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash; // 32bit ì •ìˆ˜ë¡œ ë³€í™˜
      }
      return hash.toString(36);
    }
    
    // âœ… ë¬¸ì¥ì— í•´ë‹¹í•˜ëŠ” span ì°¾ê¸° í—¬í¼ í•¨ìˆ˜
    function findSpansForSentence(textSpans, targetSentence, normalizedAllText) {
      const normalizedTarget = normalizeTextForMatching(targetSentence);
      const matchIndex = normalizedAllText.indexOf(normalizedTarget);
      
      if (matchIndex < 0) return null;
      
      let charIndex = 0;
      const matchedSpans = [];
      const matchEndIndex = matchIndex + normalizedTarget.length;
      
      for (let i = 0; i < textSpans.length; i++) {
        const span = textSpans[i];
        const spanText = normalizeTextForMatching(span.textContent || '');
        const spanLength = spanText.length;
        
        const spanStartChar = charIndex;
        const spanEndChar = charIndex + spanLength;
        
        // spanì´ ê²€ìƒ‰ ë²”ìœ„ì™€ ê²¹ì¹˜ë©´ í•˜ì´ë¼ì´íŠ¸
        if (spanStartChar < matchEndIndex && spanEndChar > matchIndex) {
          matchedSpans.push(span);
        }
        
        charIndex = spanEndChar;
        
        // ë§¤ì¹­ ë²”ìœ„ë¥¼ ë„˜ì–´ê°€ë©´ ì¢…ë£Œ
        if (spanEndChar >= matchEndIndex) {
          break;
        }
      }
      
      return matchedSpans.length > 0 ? matchedSpans : null;
    }
    
    // âœ… í•´ì‹œ ê¸°ë°˜ ë‹¤ë‹¨ê³„ ë§¤ì¹­ í•¨ìˆ˜ (95-99% ì •í™•ë„)
    function findSentenceWithHashMatching(textLayer, targetSentence) {
      if (!targetSentence || !textLayer) {
        return null;
      }
      
      const normalizedTarget = normalizeTextForMatching(targetSentence);
      if (normalizedTarget.length < 10) {
        return null; // ë„ˆë¬´ ì§§ì€ ë¬¸ì¥ì€ ìŠ¤í‚µ
      }
      
      const textSpans = textLayer.querySelectorAll('span');
      const allText = Array.from(textSpans).map(s => s.textContent || '').join(' ');
      const normalizedAllText = normalizeTextForMatching(allText);
      
      // âœ… Stage 1: ì •í™•í•œ í•´ì‹œ ë§¤ì¹­ (100% ì •í™•ë„)
      const targetHash = createTextHash(normalizedTarget);
      const sentences = normalizedAllText.split(/[.ã€‚!ï¼?ï¼Ÿ\n]/).map(s => s.trim()).filter(s => s.length >= 10);
      
      for (let i = 0; i < sentences.length; i++) {
        const sentenceHash = createTextHash(sentences[i]);
        if (sentenceHash === targetHash) {
          // ì •í™•í•œ ë§¤ì¹­ ë°œê²¬ - í•´ë‹¹ ë¬¸ì¥ì˜ span ì°¾ê¸°
          const matchedSpans = findSpansForSentence(textSpans, sentences[i], normalizedAllText);
          if (matchedSpans && matchedSpans.length > 0) {
            console.log(`âœ… í•´ì‹œ ê¸°ë°˜ ì •í™• ë§¤ì¹­ ì„±ê³µ: ${matchedSpans.length}ê°œ span`);
            return matchedSpans;
          }
        }
      }
      
      // âœ… Stage 2: ë¶€ë¶„ í•´ì‹œ ë§¤ì¹­ (95%+ ì •í™•ë„)
      const targetPrefix = normalizedTarget.substring(0, Math.min(50, normalizedTarget.length));
      const targetPrefixHash = createTextHash(targetPrefix);
      
      for (let i = 0; i < sentences.length; i++) {
        const sentencePrefix = sentences[i].substring(0, Math.min(50, sentences[i].length));
        const sentencePrefixHash = createTextHash(sentencePrefix);
        
        if (sentencePrefixHash === targetPrefixHash) {
          const matchedSpans = findSpansForSentence(textSpans, sentences[i], normalizedAllText);
          if (matchedSpans && matchedSpans.length > 0) {
            console.log(`âœ… í•´ì‹œ ê¸°ë°˜ ë¶€ë¶„ ë§¤ì¹­ ì„±ê³µ: ${matchedSpans.length}ê°œ span`);
            return matchedSpans;
          }
        }
      }
      
      // âœ… Stage 3: ë‹¨ì–´ ê¸°ë°˜ ìœ ì‚¬ë„ ë§¤ì¹­ (90%+ ì •í™•ë„)
      const targetWords = normalizedTarget.split(/\s+/).filter(w => w.trim().length >= 3);
      let bestMatch = null;
      let bestScore = 0;
      
      for (let i = 0; i < sentences.length; i++) {
        const sentenceWords = sentences[i].split(/\s+/).filter(w => w.trim().length >= 3);
        const matchedWords = targetWords.filter(tw => 
          sentenceWords.some(sw => sw.includes(tw) || tw.includes(sw))
        );
        
        const score = matchedWords.length / targetWords.length;
        if (score > bestScore && score >= 0.8) {
          bestScore = score;
          const matchedSpans = findSpansForSentence(textSpans, sentences[i], normalizedAllText);
          if (matchedSpans && matchedSpans.length > 0) {
            bestMatch = matchedSpans;
          }
        }
      }
      
      if (bestMatch && bestMatch.length > 0) {
        console.log(`âœ… í•´ì‹œ ê¸°ë°˜ ìœ ì‚¬ë„ ë§¤ì¹­ ì„±ê³µ: ${bestMatch.length}ê°œ span (ì ìˆ˜: ${bestScore.toFixed(2)})`);
        return bestMatch;
      }
      
      return null;
    }
    
    // âœ… PDF.js ì¢Œí‘œ ê¸°ë°˜ ì •í™• ë§¤ì¹­ í•¨ìˆ˜ (99%+ ì •í™•ë„)
    function findExactSentenceWithPDFJS(textLayer, targetSentence) {
      if (!currentPageTextContent || !targetSentence || !textLayer) {
        return null;
      }
      
      const normalizedTarget = normalizeTextForMatching(targetSentence);
      if (normalizedTarget.length < 10) {
        return null; // ë„ˆë¬´ ì§§ì€ ë¬¸ì¥ì€ ìŠ¤í‚µ
      }
      
      // âœ… 1ë‹¨ê³„: PDF.js í…ìŠ¤íŠ¸ ì•„ì´í…œìœ¼ë¡œ ì „ì²´ í…ìŠ¤íŠ¸ ì¬êµ¬ì„±
      const textItems = [];
      let fullText = '';
      let charIndex = 0;
      
      currentPageTextContent.items.forEach((item) => {
        if (item.str && item.str.trim()) {
          const normalizedItem = normalizeTextForMatching(item.str);
          const itemLength = normalizedItem.length;
          
          textItems.push({
            str: item.str,
            normalizedStr: normalizedItem,
            transform: item.transform,
            width: item.width,
            height: item.height,
            x: item.transform[4], // e ê°’ì´ X ì¢Œí‘œ
            y: item.transform[5], // f ê°’ì´ Y ì¢Œí‘œ
            fontName: item.fontName,
            dir: item.dir,
            startCharIndex: charIndex,
            endCharIndex: charIndex + itemLength
          });
          
          fullText += normalizedItem + ' ';
          charIndex += itemLength + 1; // ê³µë°± í¬í•¨
        }
      });
      
      const normalizedFullText = normalizeTextForMatching(fullText);
      
      // âœ… 2ë‹¨ê³„: ì •í™•í•œ ë§¤ì¹­ ìœ„ì¹˜ ì°¾ê¸°
      const matchIndex = normalizedFullText.indexOf(normalizedTarget);
      
      if (matchIndex >= 0) {
        // âœ… 3ë‹¨ê³„: ë§¤ì¹­ëœ í…ìŠ¤íŠ¸ ì•„ì´í…œ ì¶”ì¶œ
        const matchedItems = [];
        const matchEndIndex = matchIndex + normalizedTarget.length;
        
        for (const item of textItems) {
          // ë§¤ì¹­ ë²”ìœ„ì™€ ê²¹ì¹˜ëŠ” ì•„ì´í…œ ì°¾ê¸°
          if (item.startCharIndex < matchEndIndex && item.endCharIndex > matchIndex) {
            matchedItems.push(item);
          }
          
          // ë§¤ì¹­ ë²”ìœ„ë¥¼ ë„˜ì–´ê°€ë©´ ì¢…ë£Œ
          if (item.endCharIndex >= matchEndIndex) {
            break;
          }
        }
        
        if (matchedItems.length > 0) {
          // âœ… 4ë‹¨ê³„: í…ìŠ¤íŠ¸ ë ˆì´ì–´ì˜ span ìš”ì†Œì™€ ë§¤ì¹­
          const textSpans = textLayer.querySelectorAll('span');
          const matchedSpans = [];
          
          // í…ìŠ¤íŠ¸ ì•„ì´í…œì˜ í…ìŠ¤íŠ¸ë¡œ span ì°¾ê¸°
          let spanIndex = 0;
          for (const item of matchedItems) {
            // í•´ë‹¹ í…ìŠ¤íŠ¸ë¥¼ í¬í•¨í•˜ëŠ” span ì°¾ê¸°
            for (let i = spanIndex; i < textSpans.length; i++) {
              const span = textSpans[i];
              const spanText = normalizeTextForMatching(span.textContent || '');
              
              // í…ìŠ¤íŠ¸ ì•„ì´í…œì˜ í…ìŠ¤íŠ¸ê°€ spanì— í¬í•¨ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸
              if (spanText.includes(item.normalizedStr) || item.normalizedStr.includes(spanText)) {
                if (!matchedSpans.includes(span)) {
                  matchedSpans.push(span);
                }
                spanIndex = i + 1; // ë‹¤ìŒ spanë¶€í„° ê²€ìƒ‰
                break;
              }
            }
          }
          
          if (matchedSpans.length > 0) {
            console.log(`âœ… PDF.js ì¢Œí‘œ ê¸°ë°˜ ì •í™• ë§¤ì¹­ ì„±ê³µ: ${matchedSpans.length}ê°œ span`);
            return matchedSpans;
          }
        }
      }
      
      // âœ… 5ë‹¨ê³„: ë¶€ë¶„ ë§¤ì¹­ ì‹œë„ (ì •í™• ë§¤ì¹­ ì‹¤íŒ¨ ì‹œ)
      const targetPrefix = normalizedTarget.substring(0, Math.min(50, normalizedTarget.length));
      const prefixMatchIndex = normalizedFullText.indexOf(targetPrefix);
      
      if (prefixMatchIndex >= 0) {
        const matchedItems = [];
        const prefixMatchEndIndex = prefixMatchIndex + targetPrefix.length;
        
        for (const item of textItems) {
          if (item.startCharIndex < prefixMatchEndIndex && item.endCharIndex > prefixMatchIndex) {
            matchedItems.push(item);
          }
          if (item.endCharIndex >= prefixMatchEndIndex) {
            break;
          }
        }
        
        if (matchedItems.length > 0) {
          const textSpans = textLayer.querySelectorAll('span');
          const matchedSpans = [];
          let spanIndex = 0;
          
          for (const item of matchedItems) {
            for (let i = spanIndex; i < textSpans.length; i++) {
              const span = textSpans[i];
              const spanText = normalizeTextForMatching(span.textContent || '');
              
              if (spanText.includes(item.normalizedStr) || item.normalizedStr.includes(spanText)) {
                if (!matchedSpans.includes(span)) {
                  matchedSpans.push(span);
                }
                spanIndex = i + 1;
                break;
              }
            }
          }
          
          if (matchedSpans.length > 0) {
            console.log(`âœ… PDF.js ì¢Œí‘œ ê¸°ë°˜ ë¶€ë¶„ ë§¤ì¹­ ì„±ê³µ: ${matchedSpans.length}ê°œ span`);
            return matchedSpans;
          }
        }
      }
      
      return null;
    }
    
    // í•˜ì´ë¼ì´íŠ¸ ì ìš© í•¨ìˆ˜ (ê°œì„ ëœ ë²„ì „: ìˆœì°¨ì  ë‹¨ì–´ ë°°ì—´ + ìŠ¬ë¼ì´ë”© ìœˆë„ìš° ë§¤ì¹­)
    function applyHighlight(textLayer, keywords, searchText, currentSearchIndex = -1) {
      if (!textLayer || (!keywords.length && !searchText)) {
        console.log('âš ï¸ í•˜ì´ë¼ì´íŠ¸í•  í‚¤ì›Œë“œë‚˜ í…ìŠ¤íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤.');
        return;
      }
      
      // âœ… ê¸°ì¡´ í•˜ì´ë¼ì´íŠ¸ ì œê±°
      textLayer.querySelectorAll('.highlight, .highlight-strong, .highlight-current').forEach(el => {
        el.classList.remove('highlight', 'highlight-strong', 'highlight-current');
      });
      
      const textSpans = textLayer.querySelectorAll('span');
      let highlightCount = 0;
      
      // âœ… í˜„ì¬ ì„ íƒëœ ê²€ìƒ‰ ê²°ê³¼ ì •ë³´ ê°€ì ¸ì˜¤ê¸°
      let currentResult = null;
      if (currentSearchIndex >= 0 && currentSearchIndex < searchResults.length) {
        currentResult = searchResults[currentSearchIndex];
      }
      
      // âœ… 0ë‹¨ê³„: PDF.js ì¢Œí‘œ ê¸°ë°˜ ì •í™• ë§¤ì¹­ (ìµœìš°ì„ , 99%+ ì •í™•ë„)
      if (searchText && searchText.trim().length >= 10) {
        const pdfjsMatch = findExactSentenceWithPDFJS(textLayer, searchText);
        if (pdfjsMatch && pdfjsMatch.length > 0) {
          // âœ… PDF.js ì¢Œí‘œ ê¸°ë°˜ ë§¤ì¹­ ì„±ê³µ
          pdfjsMatch.forEach(span => {
            span.classList.add('highlight-strong');
            highlightCount++;
          });
          console.log(`âœ… PDF.js ì¢Œí‘œ ê¸°ë°˜ í•˜ì´ë¼ì´íŠ¸ ì™„ë£Œ: ${highlightCount}ê°œ span`);
          return; // PDF.js ë§¤ì¹­ ì„±ê³µ ì‹œ ì—¬ê¸°ì„œ ì¢…ë£Œ
        }
        
        // âœ… 0-1ë‹¨ê³„: í•´ì‹œ ê¸°ë°˜ ë‹¤ë‹¨ê³„ ë§¤ì¹­ (PDF.js ì‹¤íŒ¨ ì‹œ, 95-99% ì •í™•ë„)
        const hashMatch = findSentenceWithHashMatching(textLayer, searchText);
        if (hashMatch && hashMatch.length > 0) {
          // âœ… í•´ì‹œ ê¸°ë°˜ ë§¤ì¹­ ì„±ê³µ
          hashMatch.forEach(span => {
            span.classList.add('highlight-strong');
            highlightCount++;
          });
          console.log(`âœ… í•´ì‹œ ê¸°ë°˜ í•˜ì´ë¼ì´íŠ¸ ì™„ë£Œ: ${highlightCount}ê°œ span`);
          return; // í•´ì‹œ ë§¤ì¹­ ì„±ê³µ ì‹œ ì—¬ê¸°ì„œ ì¢…ë£Œ
        }
      }
      
      // âœ… 1ë‹¨ê³„: ê²€ìƒ‰ í…ìŠ¤íŠ¸ë¡œ ì •í™•í•œ ë§¤ì¹­ (ê³µë°± êµ¬ë¶„ AND ì¡°ê±´ ì§€ì›)
      if (searchText && searchText.trim().length > 0) {
        // âœ… ê°œì„ : ê³µë°±ìœ¼ë¡œ êµ¬ë¶„ëœ ê²€ìƒ‰ì–´ íŒŒì‹± (AND ì¡°ê±´)
        const searchQueries = searchText
          .split(/\s+/) // ê³µë°±(ì—°ì† ê³µë°± í¬í•¨)ìœ¼ë¡œ ë¶„í• 
          .map(q => q.trim())
          .filter(q => q.length >= 2) // ìµœì†Œ 2ì ì´ìƒ
          .map(q => normalizeTextForMatching(q)); // âœ… í…ìŠ¤íŠ¸ ì •ê·œí™” ì ìš©
        
        if (searchQueries.length > 0) {
          const isMultiSearch = searchQueries.length > 1;
          
          if (isMultiSearch) {
            // âœ… ë³µìˆ˜ ê²€ìƒ‰ì–´: ë¬¸ì¥ ë‹¨ìœ„ë¡œ ê·¸ë£¹í™”í•˜ì—¬ 2ê°œ ì´ìƒì˜ ê²€ìƒ‰ì–´ê°€ í¬í•¨ëœ ë¬¸ì¥ë§Œ í•˜ì´ë¼ì´íŠ¸
            // 1ë‹¨ê³„: ëª¨ë“  spanì˜ í…ìŠ¤íŠ¸ë¥¼ ìˆœì„œëŒ€ë¡œ í•©ì³ì„œ ì „ì²´ í…ìŠ¤íŠ¸ êµ¬ì„±
            const allText = Array.from(textSpans).map(s => s.textContent || '').join('');
            
            // 2ë‹¨ê³„: ë¬¸ì¥ìœ¼ë¡œ ë¶„í• í•˜ê³  2ê°œ ì´ìƒì˜ ê²€ìƒ‰ì–´ê°€ í¬í•¨ëœ ë¬¸ì¥ ì°¾ê¸°
            const sentenceRegex = /([^.ã€‚!ï¼?ï¼Ÿ\n]+[.ã€‚!ï¼?ï¼Ÿ\n]+)/g;
            const sentenceMatches = [];
            let match;
            
            while ((match = sentenceRegex.exec(allText)) !== null) {
              const sentenceText = match[0];
              const normalizedSentence = normalizeTextForMatching(sentenceText);
              
              // ë¬¸ì¥ì— í¬í•¨ëœ ê²€ìƒ‰ì–´ ê°œìˆ˜ í™•ì¸
              const matchedTermsCount = searchQueries.filter(query => 
                normalizedSentence.includes(query)
              ).length;
              
              // 2ê°œ ì´ìƒì˜ ê²€ìƒ‰ì–´ê°€ í¬í•¨ëœ ê²½ìš°ë§Œ ì €ì¥
              if (matchedTermsCount >= 2) {
                sentenceMatches.push({
                  start: match.index,
                  end: match.index + sentenceText.length,
                  sentence: sentenceText
                });
              }
            }
            
            // ë§ˆì§€ë§‰ ë¬¸ì¥ ì²˜ë¦¬ (ë¬¸ì¥ ì¢…ë£Œ ë¬¸ìê°€ ì—†ëŠ” ê²½ìš°)
            const lastSentenceStart = sentenceMatches.length > 0 
              ? sentenceMatches[sentenceMatches.length - 1].end 
              : 0;
            if (lastSentenceStart < allText.length) {
              const lastSentence = allText.substring(lastSentenceStart);
              const normalizedLastSentence = normalizeTextForMatching(lastSentence);
              const matchedTermsCount = searchQueries.filter(query => 
                normalizedLastSentence.includes(query)
              ).length;
              
              if (matchedTermsCount >= 2) {
                sentenceMatches.push({
                  start: lastSentenceStart,
                  end: allText.length,
                  sentence: lastSentence
                });
              }
            }
            
            // 3ë‹¨ê³„: ë¬¸ì¥ì— ì†í•œ spanë“¤ì„ ì°¾ì•„ì„œ í•˜ì´ë¼ì´íŠ¸
            if (sentenceMatches.length > 0) {
              // spanë“¤ì˜ ë¬¸ì ìœ„ì¹˜ ê³„ì‚°
              let charIndex = 0;
              const spanPositions = [];
              
              Array.from(textSpans).forEach((span) => {
                const spanText = span.textContent || '';
                const spanLength = spanText.length;
                spanPositions.push({
                  span: span,
                  start: charIndex,
                  end: charIndex + spanLength
                });
                charIndex += spanLength;
              });
              
              // ê° ë¬¸ì¥ì— ì†í•œ spanë“¤ ì°¾ê¸°
              sentenceMatches.forEach((sentenceMatch) => {
                spanPositions.forEach((spanPos) => {
                  // spanì´ ë¬¸ì¥ ë²”ìœ„ì™€ ê²¹ì¹˜ë©´ í•˜ì´ë¼ì´íŠ¸
                  if (spanPos.start < sentenceMatch.end && spanPos.end > sentenceMatch.start) {
                    // âœ… í˜„ì¬ ì„ íƒëœ ê²€ìƒ‰ ê²°ê³¼ì¸ì§€ í™•ì¸
                    const isCurrentResult = currentResult && 
                                           currentResult.page === currentPage;
                    
                    if (isCurrentResult) {
                      spanPos.span.classList.add('highlight-current');
                    } else {
                      spanPos.span.classList.add('highlight-strong');
                    }
                    highlightCount++;
                  }
                });
              });
              
              // 4ë‹¨ê³„: ë¬¸ì¥ í•˜ì´ë¼ì´íŠ¸ ì™„ë£Œ (ê°œë³„ ë‹¨ì–´ëŠ” ë¬¸ì¥ í•˜ì´ë¼ì´íŠ¸ ë‚´ì—ì„œ ìë™ìœ¼ë¡œ í¬í•¨ë¨)
              
              console.log(`âœ… ë³µìˆ˜ ê²€ìƒ‰ì–´ ë¬¸ì¥ ë‹¨ìœ„ í•˜ì´ë¼ì´íŠ¸ ì ìš© ì™„ë£Œ: ${highlightCount}ê°œ span (${sentenceMatches.length}ê°œ ë¬¸ì¥)`);
              return; // ê²€ìƒ‰ í…ìŠ¤íŠ¸ë¡œ í•˜ì´ë¼ì´íŠ¸í–ˆìœ¼ë©´ í‚¤ì›Œë“œ í•˜ì´ë¼ì´íŠ¸ëŠ” ìŠ¤í‚µ
            } else {
              console.log(`âš ï¸ 2ê°œ ì´ìƒì˜ ê²€ìƒ‰ì–´ê°€ í¬í•¨ëœ ë¬¸ì¥ì„ ì°¾ì„ ìˆ˜ ì—†ìŒ`);
            }
          } else {
            // âœ… ê°œì„ ëœ ë°©ì‹: ë‹¨ì¼ ê²€ìƒ‰ì–´ - ì •í™•í•œ ë§¤ì¹­ ìš°ì„  + ë‹¨ì–´ ìˆœì„œ ê³ ë ¤
            const trimmedSearchText = searchText.trim();
            const normalizedSearchText = normalizeTextForMatching(trimmedSearchText);
            const query = searchQueries[0];
            
            // âœ… í˜„ì¬ í˜ì´ì§€ì˜ ëª¨ë“  ê²€ìƒ‰ ê²°ê³¼ ì°¾ê¸°
            const currentPageResults = searchResults.filter(r => r.page === currentPage);
            let currentResultIndex = -1;
            if (currentResult && currentResult.page === currentPage) {
              currentResultIndex = currentPageResults.findIndex(r => 
                r.page === currentResult.page && 
                r.position === currentResult.position
              );
            }
            
            // âœ… ê°œì„  1: ì •í™•í•œ ë¬¸ìì—´ ë§¤ì¹­ ë¨¼ì € ì‹œë„
            const allText = Array.from(textSpans).map(s => s.textContent || '').join(' ');
            const normalizedAllText = normalizeTextForMatching(allText);
            
            // ëª¨ë“  ë§¤ì¹­ ìœ„ì¹˜ ì°¾ê¸°
            let searchStartIndex = normalizedAllText.indexOf(query);
            let matchIndex = 0;
            const allMatches = [];
            
            while (searchStartIndex !== -1) {
              const searchEndIndex = searchStartIndex + query.length;
              
              let charIndex = 0;
              const matchedSpans = [];
              
              for (let i = 0; i < textSpans.length; i++) {
                const span = textSpans[i];
                const spanText = span.textContent || '';
                const normalizedSpanText = normalizeTextForMatching(spanText);
                
                const spanStartChar = charIndex;
                const spanEndChar = charIndex + normalizedSpanText.length;
                
                // spanì´ ê²€ìƒ‰ ë²”ìœ„ì™€ ê²¹ì¹˜ë©´ í•˜ì´ë¼ì´íŠ¸
                if (spanStartChar < searchEndIndex && spanEndChar > searchStartIndex) {
                  matchedSpans.push(span);
                }
                
                charIndex = spanEndChar;
              }
              
              if (matchedSpans.length > 0) {
                allMatches.push({
                  spans: matchedSpans,
                  matchIndex: matchIndex,
                  position: searchStartIndex
                });
                matchIndex++;
              }
              
              searchStartIndex = normalizedAllText.indexOf(query, searchStartIndex + 1);
            }
            
            if (allMatches.length > 0) {
              // âœ… ëª¨ë“  ë§¤ì¹­ì„ í•˜ì´ë¼ì´íŠ¸í•˜ê³ , í˜„ì¬ ì„ íƒëœ í•­ëª©ë§Œ ê°•ì¡°
              allMatches.forEach((match, matchArrayIndex) => {
                const isCurrentMatch = currentResultIndex >= 0 && 
                                      matchArrayIndex === currentResultIndex;
                
                match.spans.forEach((span) => {
                  if (isCurrentMatch) {
                    span.classList.add('highlight-current');
                  } else {
                    span.classList.add('highlight-strong');
                  }
                  highlightCount++;
                });
              });
              
              console.log(`âœ… ì •í™•í•œ ë¬¸ìì—´ ë§¤ì¹­ í•˜ì´ë¼ì´íŠ¸ ì™„ë£Œ: ${highlightCount}ê°œ span (${allMatches.length}ê°œ ë§¤ì¹­)`);
              return;
            }
            
            // âœ… ê°œì„  2: ë‹¨ì–´ ê¸°ë°˜ ë§¤ì¹­ (ë‹¨ì–´ ìˆœì„œ ê³ ë ¤)
            const searchWords = normalizedSearchText
              .split(/\s+/)
              .filter(w => w.trim().length >= 2) // ìµœì†Œ 2ì ì´ìƒ
              .filter(w => {
                // ë¶ˆí•„ìš”í•œ ë‹¨ì–´ ì œê±° (ì¡°ì‚¬, ì ‘ì†ì‚¬ ë“±)
                const stopWords = ['ì€', 'ëŠ”', 'ì´', 'ê°€', 'ì„', 'ë¥¼', 'ì—', 'ì˜', 'ì™€', 'ê³¼', 'ë„', 'ë§Œ', 'ë¡œ', 'ìœ¼ë¡œ', 'ë°', 'ë“±'];
                return !stopWords.includes(w.trim());
              });
            
            if (searchWords.length === 0) {
              console.log('âš ï¸ ê²€ìƒ‰ì–´ì—ì„œ ìœ íš¨í•œ ë‹¨ì–´ë¥¼ ì¶”ì¶œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
            } else {
              console.log(`ğŸ” ê²€ìƒ‰ì–´ ë‹¨ì–´ ë¶„ë¦¬: ${searchWords.length}ê°œ`, searchWords.slice(0, 10));
              
              // âœ… 2ë‹¨ê³„: ëª¨ë“  spanì„ ìˆœì„œëŒ€ë¡œ ë°°ì—´í•˜ê³  ë‹¨ì–´ ì¶”ì¶œ
              const spanWordArray = [];
              
              Array.from(textSpans).forEach((span, index) => {
                const text = span.textContent || '';
                if (text.trim()) {
                  // span í…ìŠ¤íŠ¸ë¥¼ ë‹¨ì–´ë¡œ ë¶„ë¦¬
                  const normalizedSpanText = normalizeTextForMatching(text);
                  const spanWords = normalizedSpanText
                    .split(/\s+/)
                    .filter(w => w.trim().length >= 1); // 1ì ì´ìƒ
                  
                  // span ì •ë³´ ì €ì¥ (ë‹¨ì–´ë“¤ê³¼ ì›ë³¸ span ìš”ì†Œ)
                  spanWordArray.push({
                    span: span,
                    words: spanWords,
                    originalText: text,
                    normalizedText: normalizedSpanText,
                    index: index
                  });
                }
              });
              
              console.log(`ğŸ“‹ span ë°°ì—´ ì™„ë£Œ: ${spanWordArray.length}ê°œ span, ì´ ${spanWordArray.reduce((sum, item) => sum + item.words.length, 0)}ê°œ ë‹¨ì–´`);
              
              // âœ… ê°œì„  3: ë‹¨ì–´ ìˆœì„œë¥¼ ê³ ë ¤í•œ ë§¤ì¹­ (ì ìˆ˜ ê¸°ë°˜) - ëª¨ë“  ìœ íš¨í•œ ë§¤ì¹­ í•˜ì´ë¼ì´íŠ¸
              const windowSize = Math.max(3, Math.ceil(searchWords.length * 2));
              const matchedSpanSet = new Set();
              const validMatches = []; // ëª¨ë“  ìœ íš¨í•œ ë§¤ì¹­ ì €ì¥
              
              for (let i = 0; i <= spanWordArray.length - windowSize; i++) {
                const windowSpans = spanWordArray.slice(i, i + windowSize);
                
                // ìœˆë„ìš° ë‚´ ëª¨ë“  ë‹¨ì–´ë¥¼ ìˆœì„œëŒ€ë¡œ ìˆ˜ì§‘
                const windowWords = [];
                windowSpans.forEach(item => {
                  windowWords.push(...item.words);
                });
                
                // ë‹¨ì–´ ë§¤ì¹­ ë° ìˆœì„œ ì ìˆ˜ ê³„ì‚°
                let matchedWords = 0;
                let orderScore = 0;
                let lastMatchedIndex = -1;
                const matchedWordSet = new Set();
                
                for (let j = 0; j < searchWords.length; j++) {
                  const searchWord = searchWords[j];
                  let found = false;
                  
                  // í˜„ì¬ ìœ„ì¹˜ë¶€í„° ì°¾ê¸° (ìˆœì„œ ê³ ë ¤)
                  for (let k = Math.max(0, lastMatchedIndex + 1); k < windowWords.length; k++) {
                    const windowWord = windowWords[k];
                    
                    if (windowWord.includes(searchWord) || 
                        searchWord.includes(windowWord) ||
                        isWordSimilar(windowWord, searchWord)) {
                      found = true;
                      
                      // ìˆœì„œ ì ìˆ˜ ê³„ì‚° (ì´ì „ ë‹¨ì–´ ë°”ë¡œ ë‹¤ìŒì— ì˜¤ë©´ ë†’ì€ ì ìˆ˜)
                      if (lastMatchedIndex >= 0 && k === lastMatchedIndex + 1) {
                        orderScore += 20; // ì—°ì†ëœ ê²½ìš° ê°€ì¥ ë†’ì€ ì ìˆ˜
                      } else if (lastMatchedIndex >= 0 && k - lastMatchedIndex <= 2) {
                        orderScore += 10; // ê°€ê¹Œìš´ ê²½ìš° ì¤‘ê°„ ì ìˆ˜
                      } else if (lastMatchedIndex >= 0 && k - lastMatchedIndex <= 5) {
                        orderScore += 5; // ë©€ë¦¬ ìˆëŠ” ê²½ìš° ë‚®ì€ ì ìˆ˜
                    } else {
                        orderScore += 1; // ë§¤ìš° ë¨¼ ê²½ìš° ìµœì†Œ ì ìˆ˜
                      }
                      
                      lastMatchedIndex = k;
                      break;
                    }
                  }
                  
                  if (found) {
                    matchedWords++;
                    matchedWordSet.add(searchWord);
                  }
                }
                
                const wordMatchRatio = matchedWords / searchWords.length;
                // ì´ ì ìˆ˜ = ë§¤ì¹­ ë¹„ìœ¨ ì ìˆ˜ + ìˆœì„œ ì ìˆ˜
                const totalScore = (wordMatchRatio * 100) + orderScore;
                
                // âœ… ê°œì„  4: ì¡°ê±´ ì™„í™”í•˜ì—¬ ë” ë§ì€ ë§¤ì¹­ í¬ì°© (30% ì´ìƒ ë˜ëŠ” 2ê°œ ì´ìƒ ë‹¨ì–´ ë§¤ì¹­)
                if (matchedWords >= 2 || wordMatchRatio >= 0.3 || totalScore >= 40) {
                  validMatches.push({ 
                    windowSpans, 
                    matchedWords, 
                    wordMatchRatio, 
                    totalScore,
                    orderScore,
                    matchedWordSet,
                    startIndex: i
                  });
                }
              }
              
              // âœ… ê°œì„  5: ëª¨ë“  ìœ íš¨í•œ ë§¤ì¹­ì„ í•˜ì´ë¼ì´íŠ¸ (ì¤‘ë³µ ë°©ì§€)
              if (validMatches.length > 0) {
                // ì ìˆ˜ ìˆœìœ¼ë¡œ ì •ë ¬ (ë†’ì€ ì ìˆ˜ë¶€í„°)
                validMatches.sort((a, b) => b.totalScore - a.totalScore);
                
                console.log(`âœ… ìœ íš¨í•œ ë§¤ì¹­ ë°œê²¬: ${validMatches.length}ê°œ`);
                
                // ëª¨ë“  ìœ íš¨í•œ ë§¤ì¹­ì„ í•˜ì´ë¼ì´íŠ¸ (ì¤‘ë³µ spanì€ ì œì™¸)
                validMatches.forEach((match, idx) => {
                  match.windowSpans.forEach(item => {
                    if (!matchedSpanSet.has(item.span)) {
                      item.span.classList.add('highlight-strong');
                      matchedSpanSet.add(item.span);
                          highlightCount++;
                        }
                      });
                  
                  if (idx < 3) { // ìƒìœ„ 3ê°œë§Œ ë¡œê·¸ ì¶œë ¥
                    console.log(`  ë§¤ì¹­ ${idx + 1}: ${match.matchedWords}/${searchWords.length} (${(match.wordMatchRatio * 100).toFixed(1)}%), ìˆœì„œ ì ìˆ˜: ${match.orderScore}, ì´ ì ìˆ˜: ${match.totalScore.toFixed(1)}`);
                  }
                });
                
                if (highlightCount > 0) {
                  console.log(`âœ… ë‹¨ì–´ ìˆœì„œ ê³ ë ¤ ë§¤ì¹­ í•˜ì´ë¼ì´íŠ¸ ì™„ë£Œ: ${highlightCount}ê°œ span`);
                  return;
                }
              }
              
              // âœ… í´ë°±: ê¸°ì¡´ ë¡œì§ (ë‹¨ì–´ ìˆœì„œ ê³ ë ¤ ì—†ì´) - ì¡°ê±´ ì™„í™” ë° ëª¨ë“  ë§¤ì¹­ í•˜ì´ë¼ì´íŠ¸
              if (highlightCount === 0) {
                console.log('âš ï¸ ìˆœì„œ ê³ ë ¤ ë§¤ì¹­ ì‹¤íŒ¨, ê¸°ì¡´ ë°©ì‹ìœ¼ë¡œ ì¬ì‹œë„...');
                
                const baseWindowSize = Math.max(5, searchWords.length * 2);
                const maxWindowSize = Math.min(baseWindowSize, spanWordArray.length);
                const fallbackWindowSize = Math.min(maxWindowSize, Math.max(3, Math.ceil(searchWords.length * 1.5)));
                const fallbackMatches = []; // ëª¨ë“  ìœ íš¨í•œ í´ë°± ë§¤ì¹­ ì €ì¥
                
                for (let i = 0; i <= spanWordArray.length - fallbackWindowSize; i++) {
                  const windowSpans = spanWordArray.slice(i, i + fallbackWindowSize);
                  const windowWords = [];
                  windowSpans.forEach(item => {
                    windowWords.push(...item.words);
                  });
                  
                  let matchedWords = 0;
                  for (const searchWord of searchWords) {
                    const found = windowWords.some(windowWord => {
                      return windowWord.includes(searchWord) || 
                             searchWord.includes(windowWord) ||
                             isWordSimilar(windowWord, searchWord);
                    });
                    if (found) {
                      matchedWords++;
                    }
                  }
                  
                  const wordMatchRatio = matchedWords / searchWords.length;
                  // âœ… ì¡°ê±´ ì™„í™”: 2ê°œ ì´ìƒ ë‹¨ì–´ ë˜ëŠ” 30% ì´ìƒ ë§¤ì¹­
                  if (matchedWords >= 2 || wordMatchRatio >= 0.3) {
                    fallbackMatches.push({
                      windowSpans,
                      matchedWords,
                      wordMatchRatio,
                      startIndex: i
                    });
                  }
                }
                
                // ëª¨ë“  ìœ íš¨í•œ í´ë°± ë§¤ì¹­ í•˜ì´ë¼ì´íŠ¸
                if (fallbackMatches.length > 0) {
                  console.log(`âœ… í´ë°± ë§¤ì¹­ ë°œê²¬: ${fallbackMatches.length}ê°œ`);
                  fallbackMatches.forEach((match, idx) => {
                    match.windowSpans.forEach(item => {
                      if (!matchedSpanSet.has(item.span)) {
                        item.span.classList.add('highlight-strong');
                        matchedSpanSet.add(item.span);
                    highlightCount++;
                  }
                });
                    
                    if (idx < 3) { // ìƒìœ„ 3ê°œë§Œ ë¡œê·¸ ì¶œë ¥
                      console.log(`  í´ë°± ë§¤ì¹­ ${idx + 1}: ${match.matchedWords}/${searchWords.length} (${(match.wordMatchRatio * 100).toFixed(1)}%)`);
              }
                  });
              
              if (highlightCount > 0) {
                    console.log(`âœ… í´ë°± ë§¤ì¹­ í•˜ì´ë¼ì´íŠ¸ ì™„ë£Œ: ${highlightCount}ê°œ span`);
                    return;
                  }
                }
              }
              
              if (highlightCount === 0) {
                console.log('âš ï¸ ë‹¨ì–´ ë‹¨ìœ„ ë§¤ì¹­ ì‹¤íŒ¨: ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ” ë§¤ì¹­ì„ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.');
              }
            }
          }
        }
      }
      
      // âœ… 2ë‹¨ê³„: í‚¤ì›Œë“œ í•˜ì´ë¼ì´íŠ¸ (ì§§ê³  ì •í™•í•œ í‚¤ì›Œë“œë§Œ, ë‹¨ì–´ ë‹¨ìœ„ ë§¤ì¹­)
      if (keywords.length > 0) {
        const shortKeywords = keywords.filter(k => k && k.trim().length >= 3 && k.trim().length <= 20); // 3~20ìë§Œ
        
        textSpans.forEach((span) => {
          const text = span.textContent || '';
          if (!text.trim()) return;
          
          let shouldHighlight = false;
          
          for (const keyword of shortKeywords) {
            const trimmedKeyword = keyword.trim();
            // âœ… ì •í™•í•œ ë‹¨ì–´ ë‹¨ìœ„ ë§¤ì¹­ ì‹œë„ (ì˜ì–´/ìˆ«ì í¬í•¨)
            const keywordRegex = new RegExp(`\\b${trimmedKeyword.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b`, 'i');
            
            // ë‹¨ì–´ ë‹¨ìœ„ ë§¤ì¹­ ë˜ëŠ” ì§ì ‘ í¬í•¨ í™•ì¸ (í•œê¸€ì˜ ê²½ìš° ë‹¨ì–´ ê²½ê³„ê°€ ëª…í™•í•˜ì§€ ì•Šìœ¼ë¯€ë¡œ í¬í•¨ í™•ì¸ë„ ì‚¬ìš©)
            if (keywordRegex.test(text) || (trimmedKeyword.length >= 4 && text.includes(trimmedKeyword))) {
              shouldHighlight = true;
              break;
            }
          }
          
          if (shouldHighlight) {
            span.classList.add('highlight');
            highlightCount++;
          }
        });
      }
      
      console.log(`âœ… í•˜ì´ë¼ì´íŠ¸ ì ìš© ì™„ë£Œ: ${highlightCount}ê°œ ìš”ì†Œ`);
    }
    
    // í•˜ì´ë¼ì´íŠ¸ëœ ìš”ì†Œë¡œ ìŠ¤í¬ë¡¤ (ì¢Œì¸¡ í…ìŠ¤íŠ¸ë·°ì™€ ë™ì¼í•œ ë¡œì§)
    function scrollToHighlight(textLayer, attempt = 0) {
      // âœ… í˜„ì¬ ì„ íƒëœ í•­ëª© ìš°ì„ , ì—†ìœ¼ë©´ ì¼ë°˜ í•˜ì´ë¼ì´íŠ¸
      const highlighted = textLayer.querySelector('.highlight-current, .highlight-strong, .highlight');
      
      if (!highlighted) {
        // í•˜ì´ë¼ì´íŠ¸ê°€ ì—†ìœ¼ë©´ ì¬ì‹œë„
        if (attempt < 3) {
          setTimeout(() => scrollToHighlight(textLayer, attempt + 1), 200);
        } else {
          viewerWrapper.scrollTop = 0;
          console.log('ğŸ“ í•˜ì´ë¼ì´íŠ¸ ì—†ìŒ, í˜ì´ì§€ ìƒë‹¨ìœ¼ë¡œ ìŠ¤í¬ë¡¤');
        }
        return;
      }
      
      // âœ… ìš”ì†Œê°€ í™”ë©´ì— ë³´ì´ëŠ”ì§€ í™•ì¸í•˜ëŠ” í•¨ìˆ˜
      const isElementVisible = (element, container) => {
        const containerRect = container.getBoundingClientRect();
        const elementRect = element.getBoundingClientRect();
        
        // ìš”ì†Œê°€ ì»¨í…Œì´ë„ˆì˜ ê°€ì‹œ ì˜ì—­ ë‚´ì— ìˆëŠ”ì§€ í™•ì¸ (ì¼ë¶€ë§Œ ë³´ì—¬ë„ true)
        return (
          elementRect.top < containerRect.bottom &&
          elementRect.bottom > containerRect.top &&
          elementRect.left < containerRect.right &&
          elementRect.right > containerRect.left
        );
      };
      
      // âœ… ìš”ì†Œê°€ í™”ë©´ì— ë³´ì´ëŠ”ì§€ í™•ì¸
      const isVisible = isElementVisible(highlighted, viewerWrapper);
      
      if (!isVisible || attempt === 0) {
        console.log('ğŸ“ í•˜ì´ë¼ì´íŠ¸ ìœ„ì¹˜ë¡œ ìŠ¤í¬ë¡¤ ì¤‘...');
        
        // âœ… ì¦‰ì‹œ ìŠ¤í¬ë¡¤ (smoothê°€ ì‹¤íŒ¨í•  ìˆ˜ ìˆìœ¼ë¯€ë¡œ)
        const containerRect = viewerWrapper.getBoundingClientRect();
        const elementRect = highlighted.getBoundingClientRect();
        const scrollTop = viewerWrapper.scrollTop;
        
        // âœ… ìš”ì†Œê°€ ì»¨í…Œì´ë„ˆì˜ ì¤‘ì•™ì— ì˜¤ë„ë¡ ìŠ¤í¬ë¡¤ ê³„ì‚° (ì—¬ìœ  ê³µê°„ ì¶”ê°€)
        const offset = 50; // ìƒí•˜ ì—¬ìœ  ê³µê°„
        const targetScrollTop = scrollTop + elementRect.top - containerRect.top - (containerRect.height / 2) + (elementRect.height / 2) - offset;
        
        // ì¦‰ì‹œ ìŠ¤í¬ë¡¤
        viewerWrapper.scrollTop = targetScrollTop;
        
        // âœ… ìŠ¤í¬ë¡¤ í›„ ë‹¤ì‹œ í™•ì¸í•˜ì—¬ í™•ì‹¤íˆ ë³´ì´ë„ë¡ í•¨
        setTimeout(() => {
          const newElementRect = highlighted.getBoundingClientRect();
          const newContainerRect = viewerWrapper.getBoundingClientRect();
          const isNowVisible = (
            newElementRect.top < newContainerRect.bottom &&
            newElementRect.bottom > newContainerRect.top
          );
          
          if (!isNowVisible && attempt < 2) {
            // ì—¬ì „íˆ ë³´ì´ì§€ ì•Šìœ¼ë©´ ë‹¤ì‹œ ì‹œë„
            scrollToHighlight(textLayer, attempt + 1);
          } else {
            // âœ… ë¶€ë“œëŸ¬ìš´ ìŠ¤í¬ë¡¤ë¡œ ìµœì¢… ì¡°ì •
            viewerWrapper.scrollTo({
              top: viewerWrapper.scrollTop,
              behavior: 'smooth'
            });
            console.log('âœ… í•˜ì´ë¼ì´íŠ¸ ìœ„ì¹˜ë¡œ ìŠ¤í¬ë¡¤ ì™„ë£Œ');
          }
        }, 100);
      } else {
        // ì´ë¯¸ ë³´ì´ëŠ” ê²½ìš°
        console.log('âœ… í•˜ì´ë¼ì´íŠ¸ê°€ ì´ë¯¸ í™”ë©´ì— ë³´ì…ë‹ˆë‹¤');
      }
    }
    
    // âœ… performSearch í•¨ìˆ˜ëŠ” ì œê±°ë˜ì—ˆìŠµë‹ˆë‹¤. ê²€ìƒ‰ ì´ë²¤íŠ¸ëŠ” pdfSearchMessageHandler.jsì—ì„œ ì²˜ë¦¬í•©ë‹ˆë‹¤.
    
    // ê²€ìƒ‰ ê²°ê³¼ë¡œ ì´ë™
    function navigateToSearchResult(index) {
      if (index < 0 || index >= searchResults.length) return;
      
      currentSearchIndex = index;
      const result = searchResults[index];
      
      console.log(`ğŸ“„ ê²€ìƒ‰ ê²°ê³¼ ${index + 1}/${searchResults.length}ë¡œ ì´ë™: í˜ì´ì§€ ${result.page}`);
      
      // í˜ì´ì§€ ë³€ê²½
      if (currentPage !== result.page) {
        currentPage = result.page;
        queueRenderPage(currentPage);
        // í˜ì´ì§€ ë Œë”ë§ ì™„ë£Œ í›„ í•˜ì´ë¼ì´íŠ¸ (renderPage í•¨ìˆ˜ ë‚´ì—ì„œ ì²˜ë¦¬ë¨)
      } else {
        // ê°™ì€ í˜ì´ì§€ë©´ í•˜ì´ë¼ì´íŠ¸ë§Œ ì—…ë°ì´íŠ¸
        const textLayerDiv = document.querySelector('.textLayer');
        if (textLayerDiv) {
          setTimeout(() => {
            applyHighlight(textLayerDiv, [], currentSearchText, index);
            // âœ… ì—¬ëŸ¬ ë²ˆ ì‹œë„í•˜ì—¬ í™•ì‹¤íˆ ë³´ì´ë„ë¡
            scrollToHighlight(textLayerDiv, 0);
            
            setTimeout(() => {
              scrollToHighlight(textLayerDiv, 1);
            }, 500);
            
            setTimeout(() => {
              scrollToHighlight(textLayerDiv, 2);
            }, 1000);
          }, 300);
        }
      }
      
      updateSearchNav();
    }
    
    // ê²€ìƒ‰ ë„¤ë¹„ê²Œì´ì…˜ UI ì—…ë°ì´íŠ¸
    function updateSearchNav() {
      if (searchResults.length === 0) {
        searchNav.style.display = 'none';
        return;
      }
      
      searchCounter.textContent = `${currentSearchIndex + 1}/${searchResults.length}`;
      searchPrevBtn.disabled = currentSearchIndex <= 0;
      searchNextBtn.disabled = currentSearchIndex >= searchResults.length - 1;
    }
    
    // í˜ì´ì§€ ë³€ê²½ í
    function queueRenderPage(num) {
      console.log(`ğŸ“‹ queueRenderPage í˜¸ì¶œ: ${num}, ë Œë”ë§ ì¤‘: ${pageRendering}`);
      if (pageRendering) {
        console.log(`â¸ï¸ ë Œë”ë§ ì¤‘ì´ë¯€ë¡œ í˜ì´ì§€ ${num} ëŒ€ê¸° íì— ì¶”ê°€`);
        pageNumPending = num;
      } else {
        console.log(`â–¶ï¸ ì¦‰ì‹œ í˜ì´ì§€ ${num} ë Œë”ë§ ì‹œì‘`);
        renderPage(num);
      }
    }
    
    // ë²„íŠ¼ ìƒíƒœ ì—…ë°ì´íŠ¸
    function updateButtons() {
      prevBtn.disabled = currentPage <= 1;
      nextBtn.disabled = currentPage >= numPages;
    }
    
    // ì´ì „ í˜ì´ì§€
    prevBtn.addEventListener('click', () => {
      if (currentPage <= 1) return;
      currentPage--;
      queueRenderPage(currentPage);
    });
    
    // ë‹¤ìŒ í˜ì´ì§€
    nextBtn.addEventListener('click', () => {
      if (currentPage >= numPages) return;
      currentPage++;
      queueRenderPage(currentPage);
    });
    
    // í˜ì´ì§€ ì…ë ¥
    pageInput.addEventListener('change', () => {
      const page = parseInt(pageInput.value, 10);
      if (page >= 1 && page <= numPages) {
        currentPage = page;
        queueRenderPage(currentPage);
      } else {
        pageInput.value = currentPage;
      }
    });
    
    // ë‹«ê¸° ë²„íŠ¼
    closeBtn.addEventListener('click', () => {
      window.close();
    });
    
    // ê²€ìƒ‰ ì…ë ¥ í•„ë“œ ì´ë²¤íŠ¸
    searchInput.addEventListener('input', () => {
      // ê²€ìƒ‰ì–´ê°€ ë¹„ì–´ìˆìœ¼ë©´ ê²€ìƒ‰ ë²„íŠ¼ ë¹„í™œì„±í™”
      searchButton.disabled = !searchInput.value.trim();
    });
    
    // âœ… ê²€ìƒ‰ ì´ë²¤íŠ¸ëŠ” pdfSearchMessageHandler.jsì—ì„œ ì²˜ë¦¬í•©ë‹ˆë‹¤
    
    // ê²€ìƒ‰ ì´ì „/ë‹¤ìŒ ë²„íŠ¼
    searchPrevBtn.addEventListener('click', () => {
      if (currentSearchIndex > 0) {
        navigateToSearchResult(currentSearchIndex - 1);
      }
    });
    
    searchNextBtn.addEventListener('click', () => {
      if (currentSearchIndex < searchResults.length - 1) {
        navigateToSearchResult(currentSearchIndex + 1);
      }
    });
    
    // í‚¤ë³´ë“œ ë‹¨ì¶•í‚¤
    document.addEventListener('keydown', (e) => {
      // Ctrl+F ë˜ëŠ” Cmd+Fë¡œ ê²€ìƒ‰ì°½ í¬ì»¤ìŠ¤ (ê¸°ë³¸ ë™ì‘ ë°©ì§€)
      if ((e.ctrlKey || e.metaKey) && e.key === 'f') {
        e.preventDefault();
        searchInput.focus();
        return;
      }
      
      // ê²€ìƒ‰ ê²°ê³¼ ë„¤ë¹„ê²Œì´ì…˜ (ê²€ìƒ‰ ì¤‘ì¼ ë•Œë§Œ)
      if (searchResults.length > 0) {
        if (e.key === 'F3' || ((e.ctrlKey || e.metaKey) && e.key === 'g')) {
          e.preventDefault();
          if (e.shiftKey) {
            // Shift+F3 ë˜ëŠ” Shift+Ctrl+G: ì´ì „ ê²°ê³¼
            if (currentSearchIndex > 0) {
              navigateToSearchResult(currentSearchIndex - 1);
            }
          } else {
            // F3 ë˜ëŠ” Ctrl+G: ë‹¤ìŒ ê²°ê³¼
            if (currentSearchIndex < searchResults.length - 1) {
              navigateToSearchResult(currentSearchIndex + 1);
            }
          }
          return;
        }
      }
      
      // í˜ì´ì§€ ë„¤ë¹„ê²Œì´ì…˜ (ê²€ìƒ‰ ì…ë ¥ í•„ë“œì— í¬ì»¤ìŠ¤ê°€ ì—†ì„ ë•Œë§Œ)
      if (document.activeElement !== searchInput) {
        if (e.key === 'ArrowLeft' && currentPage > 1) {
          currentPage--;
          queueRenderPage(currentPage);
        } else if (e.key === 'ArrowRight' && currentPage < numPages) {
          currentPage++;
          queueRenderPage(currentPage);
        }
      }
    });
    
    // âœ… í˜ì´ì§€ ë³€ê²½ ë©”ì‹œì§€ ì²˜ë¦¬ í•¨ìˆ˜ (ê³µí†µ ë¡œì§)
    function processChangePageMessage(data) {
      console.log('ğŸ”§ processChangePageMessage ì‹œì‘:', data);
      console.log('ğŸ”§ í˜„ì¬ ìƒíƒœ:', {
        currentPage,
        numPages,
        pageRendering,
        pdfDoc: !!pdfDoc
      });
      
      if (!data || !data.page || data.page <= 0) {
        console.warn('âš ï¸ ìœ íš¨í•˜ì§€ ì•Šì€ í˜ì´ì§€ ë³€ê²½ ë©”ì‹œì§€:', data);
        return;
      }
      
      // í˜ì´ì§€ ë²”ìœ„ í™•ì¸
      if (numPages > 0 && data.page > numPages) {
        console.warn(`âš ï¸ ìš”ì²­ëœ í˜ì´ì§€(${data.page})ê°€ ì´ í˜ì´ì§€ ìˆ˜(${numPages})ë¥¼ ì´ˆê³¼í•©ë‹ˆë‹¤.`);
        return;
      }
      
      // í˜„ì¬ í˜ì´ì§€ì™€ ê°™ì€ ê²½ìš° ìŠ¤í‚µ (ë¶ˆí•„ìš”í•œ ë Œë”ë§ ë°©ì§€)
      if (currentPage === data.page) {
        console.log(`â„¹ï¸ ì´ë¯¸ í˜ì´ì§€ ${data.page}ì— ìˆìŒ, ìŠ¤í‚µ`);
        return;
      }
      
      console.log(`ğŸ“„ í˜ì´ì§€ ì´ë™: ${currentPage} â†’ ${data.page}`);
      
      // í˜ì´ì§€ ì¦‰ì‹œ ë³€ê²½
      currentPage = data.page;
      
      // í•˜ì´ë¼ì´íŠ¸ í‚¤ì›Œë“œ ì—…ë°ì´íŠ¸ (í˜ì´ì§€ ë³€ê²½ ì „ì— ì—…ë°ì´íŠ¸)
      if (data.highlight && Array.isArray(data.highlight)) {
        highlightKeywords.length = 0;
        highlightKeywords.push(...data.highlight);
        console.log('ğŸ“„ í•˜ì´ë¼ì´íŠ¸ í‚¤ì›Œë“œ ì—…ë°ì´íŠ¸:', highlightKeywords);
      }
      
      // ê²€ìƒ‰ í…ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸
      if (data.searchText) {
        searchTextParam = data.searchText;
        console.log('ğŸ“„ ê²€ìƒ‰ í…ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸:', searchTextParam.substring(0, 50) + '...');
      }
      
      // í˜ì´ì§€ ë Œë”ë§ (ì¦‰ì‹œ ì‹¤í–‰)
      console.log(`ğŸš€ queueRenderPage(${currentPage}) í˜¸ì¶œ`);
      queueRenderPage(currentPage);
      
      console.log(`âœ… í˜ì´ì§€ ${data.page}ë¡œ ì´ë™ ìš”ì²­ ì™„ë£Œ`);
    }
    
    // âœ… ë¶€ëª¨ ì°½ì—ì„œ í˜ì´ì§€ ë³€ê²½ ë©”ì‹œì§€ ìˆ˜ì‹ 
    window.addEventListener('message', (event) => {
      // ë³´ì•ˆ: ê°™ì€ originì—ì„œë§Œ ë©”ì‹œì§€ ìˆ˜ì‹ 
      if (event.origin !== window.location.origin) {
        console.warn('âš ï¸ ë‹¤ë¥¸ originì—ì„œ ì˜¨ ë©”ì‹œì§€ëŠ” ë¬´ì‹œë©ë‹ˆë‹¤:', event.origin);
        return;
      }
      
      const data = event.data;
      if (data && data.type === 'changePage') {
        console.log('ğŸ“¥ í˜ì´ì§€ ë³€ê²½ ë©”ì‹œì§€ ìˆ˜ì‹ :', data);
        
        // PDFê°€ ë¡œë“œë˜ì§€ ì•Šì•˜ìœ¼ë©´ íì— ì €ì¥
        if (!pdfDoc || numPages === 0) {
          console.log('â³ PDF ë¡œë“œ ì „ ë©”ì‹œì§€ ìˆ˜ì‹ , íì— ì¶”ê°€:', data);
          queuedMessages.push(data);
          return;
        }
        
        // PDFê°€ ë¡œë“œëœ ê²½ìš° ì¦‰ì‹œ ì²˜ë¦¬
        processChangePageMessage(data);
      }
    });
    
    // âœ… ë§ˆìš°ìŠ¤ íœ ë¡œ í˜ì´ì§€ ê°„ ì´ë™ (ìŠ¤í¬ë¡¤ì´ ìƒë‹¨/í•˜ë‹¨ì— ë„ë‹¬í•˜ë©´ í˜ì´ì§€ ì´ë™)
    let wheelCooldown = false;
    viewerWrapper.addEventListener('wheel', (e) => {
      // ì¿¨ë‹¤ìš´ ì¤‘ì´ë©´ ë¬´ì‹œ
      if (wheelCooldown) return;
      
      const wrapper = viewerWrapper;
      const scrollTop = wrapper.scrollTop;
      const scrollHeight = wrapper.scrollHeight;
      const clientHeight = wrapper.clientHeight;
      
      // ìŠ¤í¬ë¡¤ì´ ìƒë‹¨ ê·¼ì²˜ì´ê³  ìœ„ë¡œ ìŠ¤í¬ë¡¤ ì‹œ
      if (scrollTop <= 10 && e.deltaY < 0 && currentPage > 1) {
        e.preventDefault();
        wheelCooldown = true;
        currentPage--;
        queueRenderPage(currentPage);
        console.log(`ğŸ“„ íœ ë¡œ ì´ì „ í˜ì´ì§€ë¡œ ì´ë™: ${currentPage}`);
        
        // ì¿¨ë‹¤ìš´ í•´ì œ (500ms í›„)
        setTimeout(() => {
          wheelCooldown = false;
        }, 500);
      }
      // ìŠ¤í¬ë¡¤ì´ í•˜ë‹¨ ê·¼ì²˜ì´ê³  ì•„ë˜ë¡œ ìŠ¤í¬ë¡¤ ì‹œ
      else if (scrollTop + clientHeight >= scrollHeight - 10 && e.deltaY > 0 && currentPage < numPages) {
        e.preventDefault();
        wheelCooldown = true;
        currentPage++;
        queueRenderPage(currentPage);
        console.log(`ğŸ“„ íœ ë¡œ ë‹¤ìŒ í˜ì´ì§€ë¡œ ì´ë™: ${currentPage}`);
        
        // ì¿¨ë‹¤ìš´ í•´ì œ (500ms í›„)
        setTimeout(() => {
          wheelCooldown = false;
        }, 500);
      }
    }, { passive: false }); // passive: falseë¡œ ì„¤ì •í•˜ì—¬ preventDefault ê°€ëŠ¥í•˜ê²Œ í•¨
  </script>
</body>
</html>

